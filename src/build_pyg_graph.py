"""
Convert RDF data from Stardog into PyTorch Geometric Data objects.
This module handles the mapping from URIs to node indices and creates the graph structure.

The input DataFrames should come from extract_from_stardog.py after querying Stardog.
"""

import pandas as pd
import torch
from torch_geometric.data import Data
from sklearn.preprocessing import LabelEncoder


def build_pyg_graph(nodes_df: pd.DataFrame, edges_df: pd.DataFrame) -> Data:
    """
    Convert nodes and edges DataFrames into a PyTorch Geometric Data object.
    
    Args:
        nodes_df: DataFrame with columns: uri, type, capacity, throughput
        edges_df: DataFrame with columns: source_uri, target_uri, relation
    
    Returns:
        PyTorch Geometric Data object
    """
    # Create URI to index mapping
    all_uris = sorted(nodes_df['uri'].unique())
    uri_to_idx = {uri: idx for idx, uri in enumerate(all_uris)}
    
    # Encode node types as integers
    type_encoder = LabelEncoder()
    node_types = type_encoder.fit_transform(nodes_df['type'].values)
    
    # Create node features: [type_encoded, capacity, throughput]
    # Normalize capacity and throughput to [0, 1] range
    capacity = nodes_df['capacity'].values
    throughput = nodes_df['throughput'].values
    
    # Normalize numeric features
    capacity_max = capacity.max() if capacity.max() > 0 else 1.0
    throughput_max = throughput.max() if throughput.max() > 0 else 1.0
    
    capacity_norm = capacity / capacity_max
    throughput_norm = throughput / throughput_max
    
    # Stack features: [type (one-hot or encoded), capacity, throughput]
    # Using one-hot encoding for type would be better, but keeping it simple
    num_node_types = len(type_encoder.classes_)
    node_features = torch.zeros((len(nodes_df), num_node_types + 2))
    
    for i, (node_type, cap, thru) in enumerate(zip(node_types, capacity_norm, throughput_norm)):
        node_features[i, node_type] = 1.0  # One-hot for type
        node_features[i, num_node_types] = cap
        node_features[i, num_node_types + 1] = thru
    
    # Build edge_index from edges DataFrame
    edge_list = []
    for _, row in edges_df.iterrows():
        source_idx = uri_to_idx[row['source_uri']]
        target_idx = uri_to_idx[row['target_uri']]
        edge_list.append([source_idx, target_idx])
    
    if len(edge_list) == 0:
        edge_index = torch.empty((2, 0), dtype=torch.long)
    else:
        edge_index = torch.tensor(edge_list, dtype=torch.long).t().contiguous()
    
    # Create PyG Data object
    data = Data(
        x=node_features,
        edge_index=edge_index,
        uri_to_idx=uri_to_idx,  # Store mapping for later use
        idx_to_uri={idx: uri for uri, idx in uri_to_idx.items()},  # Reverse mapping
        type_encoder=type_encoder  # Store encoder for later use
    )
    
    return data


def load_from_csv(nodes_path: str, edges_path: str) -> Data:
    """
    Convenience function to load data from CSV files (extracted from Stardog) and build PyG graph.
    
    Args:
        nodes_path: Path to nodes CSV file (from extract_from_stardog.py)
        edges_path: Path to edges CSV file (from extract_from_stardog.py)
    
    Returns:
        PyTorch Geometric Data object
    """
    nodes_df = pd.read_csv(nodes_path)
    edges_df = pd.read_csv(edges_path)
    return build_pyg_graph(nodes_df, edges_df)


if __name__ == '__main__':
    # Example: load from Stardog-extracted CSV files
    # These files are generated by extract_from_stardog.py
    print("Loading data from Stardog-extracted CSV files...")
    print("(Run extract_from_stardog.py first to generate these files)")
    
    try:
        data = load_from_csv('../data/nodes_from_stardog.csv', '../data/edges_from_stardog.csv')
        
        print(f"\nGraph statistics:")
        print(f"  Number of nodes: {data.x.shape[0]}")
        print(f"  Number of features per node: {data.x.shape[1]}")
        print(f"  Number of edges: {data.edge_index.shape[1]}")
        print(f"\nSample node features (first 3 nodes):")
        print(data.x[:3])
        print(f"\nEdge index shape: {data.edge_index.shape}")
        if data.edge_index.shape[1] > 0:
            print(f"First 5 edges: {data.edge_index[:, :5]}")
    except FileNotFoundError:
        print("\nError: Could not find nodes_from_stardog.csv or edges_from_stardog.csv")
        print("Please run extract_from_stardog.py first to extract data from Stardog.")

